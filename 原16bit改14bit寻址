// 向EEPROM写入数据的函数，添加写入重试机制和更详细的错误处理
void writeEEPROM(int address, const char* data, int length) {
    int maxRetries = 3;  // 最大重试次数
    for (int retry = 0; retry < maxRetries; retry++) {
        Wire.beginTransmission(EEPROM_ADDRESS);
        Wire.write((int)(address >> 8));
        Wire.write((int)(address & 0xFF));

        int bytesToWrite = length;
        if ((address % EEPROM_PAGE_SIZE) + length > EEPROM_PAGE_SIZE) {
            bytesToWrite = EEPROM_PAGE_SIZE - (address % EEPROM_PAGE_SIZE);
        }
        for (int i = 0; i < bytesToWrite; i++) {
            Wire.write(data[i]);
        }
        if (Wire.endTransmission() == 0) {
            return;  // 写入成功，直接返回
        }
        Serial.print("EEPROM写入数据出现错误，地址: ");
        Serial.println(address);
        Serial.print("正在重试...重试次数: ");
        Serial.println(retry + 1);
        delay(100);  // 重试间隔
    }
    Serial.print("多次重试后，EEPROM写入数据仍然失败，地址: ");
    Serial.println(address);
}

// 从EEPROM读取数据的函数，添加读取结果判断和错误提示
String readEEPROM(int address, int length) {
    String data = "";
    Wire.beginTransmission(EEPROM_ADDRESS);
    Wire.write((int)(address >> 8));
    Wire.write((int)(address & 0xFF));
    Wire.endTransmission(false);
    Wire.requestFrom(EEPROM_ADDRESS, length);
    int receivedBytes = 0;
    while (Wire.available()) {
        char c = Wire.read();
        data += c;
        receivedBytes++;
    }
    if (receivedBytes!= length) {
        Serial.print("从EEPROM读取数据出现错误，期望读取 ");
        Serial.print(length);
        Serial.print(" 字节，实际读取 ");
        Serial.print(receivedBytes);
        Serial.print(" 字节，地址: ");
        Serial.println(address);
    }
    return data;
}

// 从EEPROM读取定时设置数据的函数，添加数据合法性检查和读取前后延迟
void readTimingSettingsFromEEPROM() {
    delay(20);  // 读取前增加延迟
    // 读取定时1的设置
    String data = readEEPROM(0, 12);
    if (data.length() == 12) {
        bool isValid = true;
        for (int i = 0; i < 8; i++) {
            if (data[i] < '0' || data[i] > '9') {
                isValid = false;
                break;
            }
        }
        if (isValid) {
            startHourForGroup1 = data.substring(0, 2).toInt();
            startMinuteForGroup1 = data.substring(2, 4).toInt();
            endHourForGroup1 = data.substring(4, 6).toInt();
            endMinuteForGroup1 = data.substring(6, 8).toInt();
            isTimedGroup1 = data.substring(8, 9) == "1";
        } else {
            Serial.println("定时1读取到的数据存在非法字符");
        }
    }
    // 读取定时2的设置
    data = readEEPROM(12, 12);
    if (data.length() == 12) {
        bool isValid = true;
        for (int i = 0; i < 8; i++) {
            if (data[i] < '0' || data[i] > '9') {
                isValid = false;
                break;
            }
        }
        if (isValid) {
            startHourForGroup2 = data.substring(0, 2).toInt();
            startMinuteForGroup2 = data.substring(2, 4).toInt();
            endHourForGroup2 = data.substring(4, 6).toInt();
            endMinuteForGroup2 = data.substring(6, 8).toInt();
            isTimedGroup2 = data.substring(8, 9) == "1";
        } else {
            Serial.println("定时2读取到的数据存在非法字符");
        }
    }
    delay(20);  // 读取后增加延迟
}

// 将定时设置数据写入EEPROM的函数，添加地址范围检查
void writeTimingSettingsToEEPROM() {
    if (0 > 0 || 0 + 12 > EEPROM_TOTAL_SIZE) {
        Serial.println("定时设置数据写入地址超出合理范围");
        return;
    }
    // 构建定时1的数据字符串，确保格式化为固定长度（这里假设总长度12字节，格式如：00000000000，前8位分别为时分时分，最后一位为是否定时标志）
    char data1[12];
    sprintf(data1, "%02d%02d%02d%02d%c", startHourForGroup1, startMinuteForGroup1, endHourForGroup1, endMinuteForGroup1, isTimedGroup1? '1' : '0');
    // 写入定时1的数据到EEPROM
    writeEEPROM(0, data1, 12);
    // 构建定时2的数据字符串
    char data2[12];
    sprintf(data2, "%02d%02d%02d%02d%c", startHourForGroup2, startMinuteForGroup2, endHourForGroup2, endMinuteForGroup2, isTimedGroup2? '1' : '0');
    // 写入定时2的数据到EEPROM
    writeEEPROM(12, data2, 12);
}



1. 地址表示与传输的修改
 
在14bit寻址方式下，地址范围为0到16383（2^{14}-1）。原代码中使用16位地址表示（通过 Wire.write((int)(address >> 8)); 和 Wire.write((int)(address & 0xFF)); 分别传输高8位和低8位），需要改为适应14位寻址的方式。
 
- 定义一个新的变量来存储14位地址，例如 uint16_t newAddress = (address & 0x3FFF); ，这里通过与 0x3FFF 进行按位与操作，将地址截断为14位（因为 0x3FFF 的二进制表示为 0011111111111111 ，高两位被屏蔽，保留低14位地址信息）。
- 在向EEPROM传输地址时，根据设备要求的地址传输格式进行调整。如果设备要求先传输高7位地址，再传输低7位地址，可以使用以下代码：
 
cpp  
Wire.write((int)(newAddress >> 7));
Wire.write((int)(newAddress & 0x7F));
 
 
这样就将14位地址按照新的格式传输给EEPROM。
 
2. 页大小和地址范围相关计算的调整
 
原代码中定义了 EEPROM_PAGE_SIZE 为64字节，总容量 EEPROM_TOTAL_SIZE 为16384字节（基于16位寻址计算）。在14位寻址下，需要重新评估页大小和总容量的关系。
 
- 如果保持页大小为64字节不变，那么总页数变为 16384 / 64 = 256 页（因为14位寻址可表示的地址空间为16384个单元）。
- 在 writeEEPROM 函数中计算写入字节数时，需要根据新的页大小和地址范围进行调整。例如，判断是否跨页的计算应该基于14位地址和新的页大小，修改为 if ((newAddress % EEPROM_PAGE_SIZE) + length > EEPROM_PAGE_SIZE) 。
 
3. 数据写入和读取函数中地址处理的改变
 
在 writeEEPROM 和 readEEPROM 函数中，所有涉及地址操作的部分都需要按照14位寻址进行修改。
 
- 除了上述提到的地址传输部分，在计算写入或读取的起始地址、判断地址是否超出范围等操作中，都要使用新的14位地址变量 newAddress 。例如，在 readEEPROM 函数中， Wire.beginTransmission(EEPROM_ADDRESS); 之后的地址传输部分要改为新的14位地址传输方式，并且在函数内部的其他地址相关计算中，如判断读取长度是否超出范围，也要基于14位地址进行判断，确保数据的正确读写。
 
4. 定时设置数据读写相关地址的调整
 
在 writeTimingSettingsToEEPROM 和 readTimingSettingsFromEEPROM 函数中，写入和读取定时设置数据的地址也需要根据14位寻址进行调整。
 
- 原代码中定时1的数据写入地址为0，定时2的数据写入地址为12，在14位寻址下，这些地址可能需要重新映射或者根据新的地址空间规划进行调整。例如，如果仍然希望将定时1的数据存储在较低地址区域，可以将其地址调整为合适的14位地址值，同时在读取函数中也要相应地修改读取地址，确保定时设置数据能够正确地写入和读取。在进行地址调整时，需要考虑数据的完整性和一致性，以及与其他代码部分的兼容性，避免因地址改变导致数据读写错误或功能异常。
 
5. 完整修改后的代码
 
cpp  
#include <Wire.h>

// 24C128 EEPROM相关定义
#define EEPROM_ADDRESS 0x50
#define EEPROM_PAGE_SIZE 64
#define EEPROM_TOTAL_SIZE 16384  // 128K位换算成字节得到，即16384字节

// 假设这些全局变量在其他地方声明
extern int startHourForGroup1;
extern int startMinuteForGroup1;
extern int endHourForGroup1;
extern int endMinuteForGroup1;
extern bool isTimedGroup1;
extern int startHourForGroup2;
extern int startMinuteForGroup2;
extern int endHourForGroup2;
extern int endMinuteForGroup2;
extern bool isTimedGroup2;

// 向EEPROM写入数据的函数，添加写入重试机制和更详细的错误处理
void writeEEPROM(int address, const char* data, int length) {
    int maxRetries = 3;  // 最大重试次数
    for (int retry = 0; retry < maxRetries; retry++) {
        // 将地址转换为14位
        uint16_t newAddress = (address & 0x3FFF);
        Wire.beginTransmission(EEPROM_ADDRESS);
        Wire.write((int)(newAddress >> 7));  // 传输高7位地址
        Wire.write((int)(newAddress & 0x7F));  // 传输低7位地址
        int bytesToWrite = length;
        if ((newAddress % EEPROM_PAGE_SIZE) + length > EEPROM_PAGE_SIZE) {
            bytesToWrite = EEPROM_PAGE_SIZE - (newAddress % EEPROM_PAGE_SIZE);
        }
        for (int i = 0; i < bytesToWrite; i++) {
            Wire.write(data[i]);
        }
        if (Wire.endTransmission() == 0) {
            return;  // 写入成功，直接返回
        }
        Serial.print("EEPROM写入数据出现错误，地址: ");
        Serial.println(address);
        Serial.print("正在重试...重试次数: ");
        Serial.println(retry + 1);
        delay(100);  // 重试间隔
    }
    Serial.print("多次重试后，EEPROM写入数据仍然失败，地址: ");
    Serial.println(address);
}

// 从EEPROM读取数据的函数，添加读取结果判断和错误提示
String readEEPROM(int address, int length) {
    String data = "";
    // 将地址转换为14位
    uint16_t newAddress = (address & 0x3FFF);
    Wire.beginTransmission(EEPROM_ADDRESS);
    Wire.write((int)(newAddress >> 7));  // 传输高7位地址
    Wire.write((int)(newAddress & 0x7F));  // 传输低7位地址
    Wire.endTransmission(false);
    Wire.requestFrom(EEPROM_ADDRESS, length);
    int receivedBytes = 0;
    while (Wire.available()) {
        char c = Wire.read();
        data += c;
        receivedBytes++;
    }
    if (receivedBytes!= length) {
        Serial.print("从EEPROM读取数据出现错误，期望读取 ");
        Serial.print(length);
        Serial.print(" 字节，实际读取 ");
        Serial.print(receivedBytes);
        Serial.print(" 字节，地址: ");
        Serial.println(address);
    }
    return data;
}

// 从EEPROM读取定时设置数据的函数，添加数据合法性检查和读取前后延迟
void readTimingSettingsFromEEPROM() {
    delay(20);  // 读取前增加延迟
    // 读取定时1的设置
    String data = readEEPROM(0, 12);
    if (data.length() == 12) {
        bool isValid = true;
        for (int i = 0; i < 8; i++) {
            if (data[i] < '0' || data[i] > '9') {
                isValid = false;
                break;
            }
        }
        if (isValid) {
            startHourForGroup1 = data.substring(0, 2).toInt();
            startMinuteForGroup1 = data.substring(2, 4).toInt();
            endHourForGroup1 = data.substring(4, 6).toInt();
            endMinuteForGroup1 = data.substring(6, 8).toInt();
            isTimedGroup1 = data.substring(8, 9) == "1";
        } else {
            Serial.println("定时1读取到的数据存在非法字符");
        }
    }
    // 读取定时2的设置
    data = readEEPROM(12, 12);
    if (data.length() == 12) {
        bool isValid = true;
        for (int i = 0; i < 8; i++) {
            if (data[i] < '0' || data[i] > '9') {
                isValid = false;
                break;
            }
        }
        if (isValid) {
            startHourForGroup2 = data.substring(0, 2).toInt();
            startMinuteForGroup2 = data.substring(2, 4).toInt();
            endHourForGroup2 = data.substring(4, 6).toInt();
            endMinuteForGroup2 = data.substring(6, 8).toInt();
            isTimedGroup2 = data.substring(8, 9) == "1";
        } else {
            Serial.println("定时2读取到的数据存在非法字符");
        }
    }
    delay(20);  // 读取后增加延迟
}

// 将定时设置数据写入EEPROM的函数，添加地址范围检查
void writeTimingSettingsToEEPROM() {
    if (0 > 0 || 0 + 12 > EEPROM_TOTAL_SIZE) {
        Serial.println("定时设置数据写入地址超出合理范围");
        return;
    }
    // 构建定时1的数据字符串，确保格式化为固定长度（这里假设总长度12字节，格式如：00000000000，前8位分别为时分时分，最后一位为是否定时标志）
    char data1[12];
    sprintf(data1, "%02d%02d%02d%02d%c", startHourForGroup1, startMinuteForGroup1, endHourForGroup1, endMinuteForGroup1, isTimedGroup1? '1' : '0');
    // 写入定时1的数据到EEPROM
    writeEEPROM(0, data1, 12);
    // 构建定时2的数据字符串
    char data2[12];
    sprintf(data2, "%02d%02d%02d%02d%c", startHourForGroup2, startMinuteForGroup2, endHourForGroup2, endMinuteForGroup2, isTimedGroup2? '1' : '0');
    // 写入定时2的数据到EEPROM
    writeEEPROM(12, data2, 12);
}


6. 代码修改说明
 
- 在 writeEEPROM 和 readEEPROM 函数中，将16位地址转换为14位地址进行处理。通过 uint16_t newAddress = (address & 0x3FFF); 将传入的地址截断为14位，然后按照新的14位地址格式（高7位和低7位分别传输）发送给EEPROM。
- 在计算页写入字节数和判断地址相关操作时，使用新的14位地址变量 newAddress ，以确保在14位寻址模式下的正确性。例如， if ((newAddress % EEPROM_PAGE_SIZE) + length > EEPROM_PAGE_SIZE) 用于判断是否跨页写入。
- 在 writeTimingSettingsToEEPROM 和 readTimingSettingsFromEEPROM 函数中，写入和读取定时设置数据的地址仍然保持为0和12，但在实际的读写操作中，会将这些地址转换为14位地址进行处理，确保与14位寻址模式兼容。
 
请注意，以上代码假设AT24C128芯片在14位寻址模式下能够正确工作，并且设备对地址的传输和解释方式与代码中的修改一致。在实际应用中，可能需要根据芯片的具体规格和要求进行进一步的调整和测试。